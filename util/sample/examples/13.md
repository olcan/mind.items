#util/sample/examples/13 Optimize [simulation](#util/sim) outcomes under constraints. Here we simulate 4 asset classes as [geometric brownian motion](https://en.wikipedia.org/wiki/Geometric_Brownian_motion) w/ SDE $`dX_t=\mu X_t dt+\sigma X_t dB_t`$ simulated from $`X_0=1`$. Solution is $`X_t=\exp((\mu-\sigma^2/2)t+\sigma B_t)`$ distributed [log-normally](https://en.wikipedia.org/wiki/Log-normal_distribution) w/ mean `exp(μt)` and stdev `exp(μt)·sqrt(exp(σ²t)-1)`. Distributions at `t=10` determine optimal asset at target quantile `q`. Exact quantiles are plotted below.
```js
const A = 4 // assets
const q = .5 // target quantile
const μA = [.05, .025, .005, .0125] // percentage drift
const σA = [.1, .05, .01, .025] // percentage volatility
const dA = array(A, a=> μA[a] - .5*σA[a]*σA[a]) // drift - quadratic variation
const names = ['crypto', 'stocks', 'bonds', 'reits']
const alloc = array(A) // allocation (unknown parameter, array can be reused)
const portfolio = () => _state({ prices:ones(A), value:1 })
const reprice = _do(x=>{
  apply(x.prices, (x,a)=> x * exp(dA[a] + σA[a]*random_normal()))
  x.value = dot(x.prices, alloc)
})
```
#### Exact Quantiles
```js:js_removed
// pdf from https://en.wikipedia.org/wiki/Geometric_Brownian_motion
const gbm_pdf = (μ,σ,t,x0) => x => (1/sqrt(2*pi)) * (1/(x*σ*sqrt(t))) * exp(-pow((log(x)-log(x0)-(μ-σ*σ/2)*t),2)/(2*σ*σ*t))
// log-normal quantile from https://en.wikipedia.org/wiki/Log-normal_distribution
// note wikipedia log-normal σ <- σ*sqrt(t), μ <- log(x0)+(μ-σ*σ/2)*t
const gbm_quantile = (μ,σ,t,x0) => q => exp(log(x0)+(μ-σ*σ/2)*t+sqrt(2*σ*σ*t)*erf_inverse(2*q-1))
const yK = [1, 1.25, 1.5, 2, 3, 4, 5]
const qJ = array(9, j=>(j+1)/10)
const fA = array(A, a=> gbm_quantile(μA[a],σA[a],10,1))
const yAJ = round_to(array(A,a=>qJ.map(q=>fA[a](q))),3)
const options = {
  series:names.map(n=>({label:n})),
  axis:{ 
    // x: { label:{text:'quantiles', position: 'outer-center'}},
    y:{ label:'value', tick:{ values:yK }}
  },
  grid:{ y:{ lines:[{value:1}] }},
  legend: { position: 'right' }
}
```
<<lines({ x_values: qJ, values: yAJ }, options )>>
#### Simulation
```js:js_input

sample_array(A, alloc, summand(1), names)
confine(context.value('bonds') + context.value('reits'), above(.3))
const { value } = simulate(portfolio, 10, { reprice })
maximize(value, q)

```
```js:js_removed

const _sample_options = {
  context:{A},
  stats:'mks ess lwr r.0 r.x.value t ua.crypto median.x.value median.bonds median.reits',
  max_time: 10000,
  // max_time: 10000,
  // min_time: 9000, // to see degradation w/o reweights (if min_ess > 1-q)
  // opt_time: 3000,
  // min_ess: 900,
  table:true,
  plot:true,
  // log:true,
  // size:1, // debug
  async:true,
  // workers:navigator.hardwareConcurrency,
}

```
#_util #_async
