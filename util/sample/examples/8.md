#util/sample/examples/8 Sample `A∈(0,1)`, `B∈(a,1)`, `C∈(a,b)` conditioned on `C'≈.5` (approximate equality) _without computing likelihood_ `P(C'≈.5|a,b)` since it is not practical in general. We attempt three methods:
- Conditioning on interval `C'∈(.5-ε,.5+ε), ε=.0001`. This is likely to fail at initial (_prior_) sampling by failing to generate any runs that satisfy the condition, which is considered an error as it provides no information for subsequent updates and additional "blind" passes are considered too inefficient.
- Using a _weight sequence_ to condition on a sequence `ε=.0001^min(1,(u+1)/10)` of larger intervals that shrink down to the target interval in 9 updates. This typically works given enough `max_time`.
- Weighting runs as `exp{ -abs(c'-.5) * 100^min(1,(u+1)/10) }`, which converges to `exp{ -abs(c'-.5) * 100 }` in 9 updates. This can be much faster since relative ("soft") weights make _all_ runs informative, unlike conditioning ("hard") weights that provide no information among runs w/ the same weight (0 or 1).
```js:js_input

let a = sample(between(0, 1))
let b = sample(between(a, 1))
let c = sample(between(a, b))
let cc = sample(between(a, b))
const ε = .0001
// condition(abs(cc-.5) < ε)
// condition(abs(cc-.5) < ε, u => log(abs(cc-.5) < ε ** min(1,(u+1)/10)))
weight(-abs(cc-.5) * 100, u => -abs(cc-.5) * 100**min(1,(u+1)/10))

// TODO: allow both conditioning/weighting on a sampler domain!

```
```js:js_removed

const targets = transpose_objects(random_array(1000, () => {
  const a = random()
  const b = random_uniform(a, 1)
  const c = random_uniform(a, b)
  const cc = random_uniform(a, b)
  if (abs(cc-.5) < .0001) return {a, b, c}
}, defined))

const _sample_options = { 
  targets,
  stats:'mks tks ess elw t',
  plot:true,
  max_time:5000
}

```
#_util