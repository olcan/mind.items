#util/sample/examples/15 Infer more complex [simulations](#util/sim), e.g. w/ state-dependent scheduling.
```js:js_input

const x = state({
  t: _6am - round(30 * max(.25, context.r)), // start time
  alice: { awake: false }, // alice is asleep at start time
  _events: [] // enable simulated event history, used below
})
const p_alt = sample(between(0,1))
x.alice.merge({ alt: random_boolean(p_alt) })
const h_wake      = around(sample(between(6,10)), sample(between(0,2)))
const h_sleep     = around(sample(between(0,3)) , sample(between(0,2)))
const h_wake_alt  = around(sample(between(6,10)), sample(between(0,2)))
const h_sleep_alt = around(sample(between(0,3)) , sample(between(0,2)))
condition(h_wake_alt._μ + h_wake_alt._σ*.5 < h_wake._μ - h_wake._σ*.5)
simulate(x, now(), [
  wake( x.alice, daily(xa=> xa.alt ? h_wake_alt  : h_wake  )),
  sleep(x.alice, daily(xa=> xa.alt ? h_sleep_alt : h_sleep ),
    xa=> xa.alt = random_boolean(p_alt)) // resample x.alice.alt at sleep
], { allow_next:true }) // simulate to next event >now

predict(last_event_name(x)) <<- next_event_name
const sleep_lengths = hours_between_events(x, 'alice.sleep', 'alice.wake')
accumulate( // accumulate weights across runs, see notes below
  confine(event_hours(x, 'alice.wake'), logged_wake_hours),
  confine(event_hours(x, 'alice.sleep'), logged_sleep_hours),
  confine(sleep_lengths, logged_sleep_lengths)
)
predict(mean(sleep_lengths))
predict(stdev(sleep_lengths))

```
```js:js_removed

// CONVERGENCE
// accumulation inhibits relative-tail (e.g. mks_tail=.5) mks convergence
// due to "slow drift" as posterior over-concentrates around MAP (→ML) points
// accumulation also reduces sensitivity to prior s.t. MAP points → ML points
// resolved using fixed-tail mks (e.g. mks_tail=1), now default for accumulation
//
// IDENTIFIABILITY
// alt & non-alt parameters are swappable, or "non-identifiable"
// i.e. observed weights are invariant to swapping of alt & non-alt params
// due to model symmetry w.r.t. component model (alt vs non-alt) assignment
// any posterior sample becomes arbitrary mixture of two assignment variants
// posterior parameter statistics (e.g. mean) become meaningless due to mixture
// component model asymmetry (e.g. normal vs triangular) can resolve
// parameter prior asymmetry can help, but much less w/ accumulation
// resolved using component (& parameter) ordering condition (see _log_w below)
// ordering condition effectively drops one of the two assignment variants
// overhead is minimal as inconsistent samples dropped in first few updates
// overhead further minimized due to sims cancelled in inconsistent samples
//
// ATTACHED vs CAPTURED PARAMETERS
// arbitrary objects can be attached to state as parameters w/ minimal overhead
// can also be directly referenced from (and thus captured into) event functions
// below is an alternative implementation w/ all parameters attached to state
//
// x.alice.merge({
//   _params: {
//     p_alt:       sample(between(0,1)),
//     h_wake:      around(sample(between(6,10)), sample(between(0,2))),
//     h_sleep:     around(sample(between(0,3)) , sample(between(0,2))),
//     h_wake_alt:  around(sample(between(6,10)), sample(between(0,2))),
//     h_sleep_alt: around(sample(between(0,3)) , sample(between(0,2))),
//   },
//   alt: ({ p_alt }) => random_boolean(p_alt),
//   _log_w: ({ h_wake_alt, h_wake }) =>
//     log(h_wake_alt._μ + h_wake_alt._σ*.5 < h_wake._μ - h_wake._σ*.5)
// })
// simulate(x, now(), [
//   wake( x.alice, daily(xa=> xa.alt ? xa.h_wake_alt  : xa.h_wake  )),
//   sleep(x.alice, daily(xa=> xa.alt ? xa.h_sleep_alt : xa.h_sleep ),
//     xa=> xa.alt = random_boolean(xa.p_alt)) // resample x.alice.alt at sleep
// ], { allow_next:true }) // simulate to next event >now

const wake = (x, ft) => _if(x=>!x.awake, ft, x=>{ x.awake=true }, x, 'wake')
const sleep = (x, ft, fx) => _if(x=>x.awake, ft, x=>{ x.awake=false; fx?.(x) }, x, 'sleep')

const last_event_name = x => last(x._events)?._source._name
const event_hours = (x, name) => remove(x._events.map(e=>{
  if (e._source._name == name) return (e.t - ~~e.t) * 24
}))
const hours_between_events = (x, start, end) => remove(x._events.map((e,j,eJ)=>{
  if (j>0 && e._source._name == end && eJ[j-1]._source._name == start)
    return (e.t - eJ[j-1].t) * 24
}))

const context = () => ({
  logged_wake_hours: dist(event_log('wake','h')),
  logged_sleep_hours: dist(event_log('sleep','h')),
  logged_sleep_lengths: dist(event_log(undefined, (e,j,eJ) => {
    if (e.keyword == 'wake' && eJ[j+1]?.keyword == 'sleep')
      return (e.t - eJ[j+1].t) * 24
  }))
})

const _sample_options = {
  stats:'mks ess elw lwr r t',
  context, // as function defined above
  max_time:20000,
  // mks_tail:2,
  table:true,
  plot:true,
  // size:1, // debug
  async:true,
  workers:navigator.hardwareConcurrency, // ~optimal for time/sample (tpsa)
}

```
#_util #_logger #_async