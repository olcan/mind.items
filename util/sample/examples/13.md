#util/sample/examples/13
```js:js_input

sample_array(A, alloc, summand(1), 'crypto stocks bonds reits')
let x = simulate({ alloc, prices:ones(A), value:1 }, 10, events)
confine(x.value, above(5))
plot(x.value)

```
```js:js_removed

// TODO: instead of above(x), which can be hard to pick or "get right", could you just "maximize"? can you define that intuitively based on "evolving relative domains", e.g. {eq:max_so_far}, which would give log_w=0 at max and distance-based log_w everywhere else? you could probably require distance-based log_w since we need a sense of direction and progress in this case; main problem is likely to be that the domain is not achievable, so w/ rescaling log_w will remain large for most points so ess will remain small or rather r<1 will stay small to try to keep ess at reasonable level
//
//
// TODO: built-in support for a "fork" (based on copying args) may be nice to be able to see posterior predictive for conditioning variables

const A = 4 // assets
const alloc = array(A) // allocation
const μA = [.05, .025, .005, .0125] // mean change (relative) per period
const σA = [.1, .05, .01, .025] // standard deviation in change per period
const dA = array(A, a=> μA[a]-.5*σA[a]**2)
const reprice = _do(x=>{
  apply(x.prices, (x,a)=> x * exp(dA[a] + σA[a]*random_normal()))
  x.value = sum(A, a=> x.alloc[a] * x.prices[a])
})
const events = name_events(()=>reprice)

const _sample_options = { 
  params:{A},
  stats:'mks ess wsum r t ua.crypto ua.stocks ua.bonds ua.reits ua.x.value',
  max_time: 5000,
  table:true,
  plot:true,
  // log:true,
  // size:1, // debug
}

```
#_util
