#util/sample/examples/14 Confine [simulation](#util/sim) states to observed ([logged](#logger)) distributions. Weight accumulation or maximization can be used if maximum-weight (or maximum-likelihood) estimates are sufficient and over-concentrated posteriors and fixed-tail convergence (across fixed number of updates, as is default for optimization and accumulation) are acceptable.
```js:js_input

const vars = { t: _6am - 20 } // start at 6am, X days ago
const params = {}
const events = []
sleep_daily('olcan', vars, params, events)
params.olcan.wake_hour.mean = sample(between(6,10))
params.olcan.wake_hour.stdev = sample(between(0,2))
params.olcan.sleep_hour.mean = sample(between(-2,3))
params.olcan.sleep_hour.stdev = sample(between(0,2))
const x = state(vars, params, { events:true })
simulate(x, now(), events, { allow_next:true }) // simulate to next event >now
predict(last(x._events)._source._name, 'next event') // last event is next
const sleep_lengths = compute_sleep_lengths('olcan',x)
accumulate( // accumulate weights across runs, see notes below
  confine(wake_hours('olcan',x), logged_wake_hours),
  confine(sleep_hours('olcan',x), logged_sleep_hours),
  confine(sleep_lengths, logged_sleep_lengths)
)
predict(mean(sleep_lengths))
predict(stdev(sleep_lengths))

```
```js:js_removed

// performance stats (for 10 days of sim)
// before _State: pps is ~45k, aps ~20k
// _State w/o tracking, w/ array state for sleep/wake times: ~80%
// _State using _events array: ~90%
// _State using _events array, w/ tracking: ~80%

// alternative methods for weight accumulation or maximization
// note all these methods over-concentrate posterior around MAP point
// these methods assume independent samples, even though logged samples reused
//
// accumulate(
//   confine(wake_hours(x), logged_wake_hours),
//   confine(sleep_hours(x), logged_sleep_hours),
//   confine(sleep_lengths, logged_sleep_lengths)
// )
//
// accumulate(weight(
//   logged_wake_hours._log_p(wake_hours(x)) +
//   logged_sleep_hours._log_p(sleep_hours(x)) +
//   logged_sleep_lengths._log_p(sleep_lengths)
// ))
//
// maximize(
//   logged_wake_hours._log_p(wake_hours(x)) +
//   logged_sleep_hours._log_p(sleep_hours(x)) +
//   logged_sleep_lengths._log_p(sleep_lengths)
// )

function sleep_daily(name, vars, params, events) {
  assign(vars[name] ??= {}, { awake: false }) // assume asleep initially
  assign(params[name] ??= {}, {
    wake_hour: { mean: 8, stdev: 1 },
    sleep_hour: { mean: 0, stdev: 1 },
  })
  const awake = x => x[name].awake
  const asleep = x => !awake(x)
  const sleep = ft => _if(awake, ft, x=>{ x[name].awake=false })
  const wake = ft => _if(asleep, ft, x=>{ x[name].awake=true })
  const wake_hour = x => x[name].wake_hour
  const sleep_hour = x => x[name].sleep_hour
  const around_wake_hour = x => around(wake_hour(x).mean, wake_hour(x).stdev)
  const around_sleep_hour = x => around(sleep_hour(x).mean, sleep_hour(x).stdev)
  events.push(...name_events({
    [name + '.wake']: wake(daily(around_wake_hour)),
    [name + '.sleep']: sleep(daily(around_sleep_hour))
  }))
}
// TODO: refactor this code to standardize even names and event/state associations
//       (would it make sense to allow events to be defined as part of state? maybe not)
// TODO: investigate performance hit (~50%) of using nested object
function wake_hours(name, x) {
  const hours = []
  each(x._events, e=>{
    if (e._source._name.startsWith(name+'.wake')) hours.push((e.t-~~e.t)*24)
  })
  return hours
}
function sleep_hours(name, x) {
  const hours = []
  each(x._events, e=>{
    if (e._source._name.startsWith(name+'.sleep')) hours.push((e.t-~~e.t)*24)
  })
  return hours
}
function compute_sleep_lengths(name, x) {
  const lengths = []
  const eJ = x._events
  each(eJ, (e,j)=>{
    if (e._source._name.startsWith(name+'.wake') && eJ[j-1]?._source._name.startsWith(name+'.sleep'))
      lengths.push((e.t - eJ[j-1].t) * 24)
  }, 1)
  return lengths
}

// note event_log(â€¦) is NOT available on workers as it depends on cached state (event log) on _item(#logger), so we simply define context as a function (that returns a context object), which allows event-log-based arrays to be pre-computed on main thread and then passed along to workers via options.context
const context = () => ({
  logged_wake_hours: dist(event_log('wake','h')),
  logged_sleep_hours: dist(event_log('sleep','h')),
  logged_sleep_lengths: dist(event_log(undefined, (e,j,eJ) => {
    if (e.keyword == 'wake' && eJ[j+1]?.keyword == 'sleep')
      return (e.t - eJ[j+1].t) * 24
  }))
})

const _sample_options = {
  stats:'mks ess elw r t mean.maximize median.maximize',
  context, // as function defined above
  max_time:10000,
  table:true,
  plot:true,
  // size:1, // debug
  async:true,
  workers:navigator.hardwareConcurrency,
}

```
#_util #_logger #_async