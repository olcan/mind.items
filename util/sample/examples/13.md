#util/sample/examples/13
```js:js_input

sample_array(A, alloc, summand(1), 'crypto stocks bonds reits')
// copy(alloc, [1, 0, 0, 0])
let x = simulate({ alloc, prices:ones(A), value:1 }, 10, events)
let y = simulate({ alloc, prices:ones(A), value:1 }, 10, events)
// confine(x.value, above(1,10,5))
maximize(x.value)
plot(x.value)
plot(y.value)

```
```js:js_removed

// TODO: we used to disallow "random weights", or in general any non-sampled randonness, as checked during ess computation, but somehow the random simulations are not triggering it -- why not ???
//
// TODO: is it possible that conditioning is somehow fundamentally different from optimizing for posterior statistics, so we could not hope to achieve latter via former?
//
// TODO: investigate behavior for fixed alloc, e.g. [1,0,0,0]
//       x.value is being "maximized" simply by "selection among pure noise"
//       (comparable simply to _conditioning_ to larger and larger outcomes)
//       y.value does not improve at all, but is better (1.67 mean, 1.58 median) than any sampling-based optimization we are able to achieve
//
// TODO: one way to look at maximize/minimize is as a non-convergent sequence of conditions or weights; note it can be non-convergent simply because the outcome is unbounded or bounded only probabilistically, meaning it is always possible to sample and (effectively) condition on better outcomes w/o actually improving the outcomes in terms of posterior predictive; one way to handle that could be to always track a fork of the optimized variable, i.e. to resample it w/o changing any previously sampled values
//
// TODO: built-in support for a "fork" (based on copying args) may be nice to be able to see posterior predictive for conditioning variables

const A = 4 // assets
const alloc = array(A) // allocation
const μA = [.05, .025, .005, .0125] // mean change (relative) per period
const σA = [.1, .05, .01, .025] // standard deviation in change per period
const dA = array(A, a=> μA[a]-.5*σA[a]**2)
const reprice = _do(x=>{
  apply(x.prices, (x,a)=> x * exp(dA[a] + σA[a]*random_normal()))
  x.value = sum(A, a=> x.alloc[a] * x.prices[a])
})
const events = name_events(()=>reprice)

const _sample_options = { 
  params:{A},
  stats:'mks ess essu wsum r t ua.crypto median.x.value',
  max_time: 3000,
  time: 3000, // consider 3s target
  table:true,
  plot:true,
  // log:true,
  // size:1, // debug
}

```
#_util
