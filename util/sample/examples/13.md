#util/sample/examples/13
```js:js_input

sample_array(A, alloc, summand(1), 'crypto stocks bonds reits')
let x = simulate({ alloc, prices:ones(A), value:1 }, 10, events)

// TODO: seems nice to have this 'knob', but how to explain median being better at q=.9? (it does get worse above around q=.95 if that helps) but what is the best intuitive description of what this knob controls if not the posterior predictive quantile being optimized?
maximize(x.value, .9)

```
```js:js_removed

const A = 4 // assets
const alloc = [1,0,0,0] // allocation (optimal)
const μA = [.05, .025, .005, .0125] // mean change (relative) per period
                                    // crypto (0) dominates, more at higher q
// const μA = [.04, .05, .05, .05]  // <- 0 @q=.9, 1 @q=.8
// const μA = [.05, .05, .05, .05] // <-- 0 @q>.7, 3 @q<.4
const σA = [.1, .05, .01, .025] // standard deviation in change per period
const dA = array(A, a=> μA[a]-.5*σA[a]**2)
const reprice = _do(x=>{
  apply(x.prices, (x,a)=> x * exp(dA[a] + σA[a]*random_normal()))
  x.value = sum(A, a=> x.alloc[a] * x.prices[a])
})
const events = name_events(()=>reprice)

const _sample_options = { 
  params:{A},
  stats:'ess wsum r t ua.crypto median.x.value',
  max_time: 5000,
  // min_time: 9000,
  // opt_time: 3000,
  table:true,
  plot:true,
  // log:true,
  // size:1, // debug
}

```
#_util
