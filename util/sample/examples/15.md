#util/sample/examples/15 Infer more complex [simulations](#util/sim), e.g. w/ state-dependent scheduling.
```js:js_input

const x = state({
  t: _6am - round(30 * max(.25, context.r)), // start time
  alice: { awake: false }, // alice is asleep at start time
  _events: [] // enable simulated event history, used below
})
const p_alt = sample(between(0,1))
x.alice.merge({ alt: random_boolean(p_alt) })
const h_wake      = around(sample(between(6,10))<<-μ, sample(between(0,2))<<-σ)
const h_sleep     = around(sample(between(0,3)) <<-μ, sample(between(0,2))<<-σ)
const h_wake_alt  = around(sample(between(6,10))<<-μ, sample(between(0,2))<<-σ)
const h_sleep_alt = around(sample(between(0,3)) <<-μ, sample(between(0,2))<<-σ)
condition(h_wake_alt._μ + h_wake_alt._σ*.5 < h_wake._μ - h_wake._σ*.5)
simulate(x, now(), [
  wake( x.alice, daily(xa=> xa.alt ? h_wake_alt  : h_wake  )),
  sleep(x.alice, daily(xa=> xa.alt ? h_sleep_alt : h_sleep ),
    xa=> xa.alt = random_boolean(p_alt)) // resample x.alice.alt at sleep
], { allow_next:true }) // simulate to next event >now
predict(last_event_name(x)) <<- next_event_name
const sleep_lengths = hours_between_events(x, 'alice.sleep', 'alice.wake')
accumulate( // accumulate weights across runs, see notes below
  confine(event_hours(x, 'alice.wake'), logged_wake_hours),
  confine(event_hours(x, 'alice.sleep'), logged_sleep_hours),
  confine(sleep_lengths, logged_sleep_lengths)
)
predict(mean(sleep_lengths))
predict(stdev(sleep_lengths))

```
```js:js_removed

// CONVERGENCE
// accumulation inhibits relative-tail (e.g. mks_tail=.5) mks convergence
// due to "slow drift" as posterior over-concentrates around MAP (→ML) points
// accumulation also reduces sensitivity to prior s.t. MAP points → ML points
// resolved using fixed-tail mks (e.g. mks_tail=1), now default for accumulation
//
// IDENTIFIABILITY
// alt & non-alt parameters are swappable, or "non-identifiable"
// i.e. observed weights are invariant to swapping of alt & non-alt params
// due to model symmetry w.r.t. component model (alt vs non-alt) assignment
// any posterior sample becomes arbitrary mixture of two assignment variants
// posterior parameter statistics (e.g. mean) become meaningless due to mixture
// component model asymmetry (e.g. normal vs triangular) can resolve
// parameter prior asymmetry can help, but much less w/ accumulation
// resolved using component (& parameter) ordering condition (see _log_w below)
// ordering condition effectively drops one of the two assignment variants
// overhead is minimal as inconsistent samples dropped in first few updates
// overhead further minimized due to sims cancelled in inconsistent samples
//
// ALTERNATIVE IMPLEMENTATION (via state-attached parameters)
// function wake_sleep_events(x, params={}, state={}, events={}) {
//   x.merge({
//     _params: {
//       wake_hour: { mean: 8, stdev: 1 },
//       sleep_hour: { mean: 0, stdev: 1 },
//       alt_wake_hour: { mean: 7, stdev: 1 }, // < wake_hour for identifiability
//       alt_sleep_hour: { mean: 0, stdev: 1 },
//       p_alt: .5, // prob. alt schedule for first/next wake+sleep
//       // apply weight (_log_w) to order model components s.t. alt_wake < wake
//       // inconsistent (_log_w==-inf) samples are dropped (and sims cancelled)
//       _log_w: ({ alt_wake_hour, wake_hour })=>
//         log(alt_wake_hour.mean + alt_wake_hour.stdev*.5 <
//           wake_hour.mean - wake_hour.stdev*.5),
//       ...params
//     },
//     alt: ({ p_alt }) => random_boolean(p_alt),
//     ...state
//   })
//   // precompute fixed values that depend only on params (vs variable state)
//   // prevents expensive recomputation of domain objects in daily(x=>…)
//   const around_hour = h => around(h.mean, h.stdev)
//   const wake_hour = around_hour(x.wake_hour)
//   const sleep_hour = around_hour(x.sleep_hour)
//   const alt_wake_hour = around_hour(x.alt_wake_hour)
//   const alt_sleep_hour = around_hour(x.alt_sleep_hour)
//   // note we attach_events(x,…) to ensure all functions are passed same x
//   // keeps event functions context-free and prevents ambiguity below
//   const wake_sched = daily(x=> x.alt ? alt_wake_hour : wake_hour)
//   const sleep_sched = daily(x=> x.alt ? alt_sleep_hour : sleep_hour)
//   return attach_events(x, name_events({
//     [path(x,'wake')]: _if(x=>!x.awake, wake_sched, x=>{ x.awake=true }),
//     [path(x,'sleep')]: _if(x=>x.awake, sleep_sched, x=>{
//       x.alt = random_boolean(x.p_alt) // use alt schedule for next wake+sleep?
//       x.awake = false
//     }),
//     ...events
//   }))
// }

const wake = (x, ft) => _if(x=>!x.awake, ft, x=>{ x.awake=true }, x, 'wake')
const sleep = (x, ft, fx) => _if(x=>x.awake, ft, x=>{ x.awake=false; fx?.(x) }, x, 'sleep')

const last_event_name = x => last(x._events)?._source._name
const event_hours = (x, name) => remove(x._events.map(e=>{
  if (e._source._name == name) return (e.t - ~~e.t) * 24
}))
const hours_between_events = (x, start, end) => remove(x._events.map((e,j,eJ)=>{
  if (j>0 && e._source._name == end && eJ[j-1]._source._name == start)
    return (e.t - eJ[j-1].t) * 24
}))

const context = () => ({
  logged_wake_hours: dist(event_log('wake','h')),
  logged_sleep_hours: dist(event_log('sleep','h')),
  logged_sleep_lengths: dist(event_log(undefined, (e,j,eJ) => {
    if (e.keyword == 'wake' && eJ[j+1]?.keyword == 'sleep')
      return (e.t - eJ[j+1].t) * 24
  }))
})

const _sample_options = {
  stats:'mks ess elw lwr r t',
  context, // as function defined above
  max_time:20000,
  // mks_tail:2,
  table:true,
  plot:true,
  // size:1, // debug
  async:true,
  workers:navigator.hardwareConcurrency, // ~optimal for time/sample (tpsa)
}

```
#_util #_logger #_async