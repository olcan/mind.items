#util/sample/examples/8 Sample `A∈[0,1)`, `B∈[a,1)`, `C∈[a,b)` conditioned on `C'=.5` using likelihood weight (density) `P(C'=.5|a,b)`. In this case the equivalent conditioning can only be _approximated_ using a small interval `C'∈(.5-ε,.5+ε)` and only with cost increasing as `∝ 1/ε`. Indeed this requires extra time even at `ε=.005` as shown in example #//5. Also note the weights here involve a conditioning on `.5∈[A,B)`, a much more probable event compared to `C'∈(.5-ε,.5+ε)` for small `ε`.
```js:js_input

sample(() => {
  let a = sample(uniform(0, 1)) // uniform prior on [0,1]
  let b = sample(uniform(a, 1)) // uniform cond. prior on [a,1]
  let c = sample(uniform(a, b)) // uniform cond. prior on [a,b]
  let cc = sample(uniform(a, b)) // uniform cond. prior on [a,b]
  
  // TODO: it seems you want the weight sequence to depend on target ess
  //       to allow time for ess to go back up after reweights
  // TODO: do you want to have a 'cu' function or is that too minor
  condition(cc > .4999 && cc < .5001, u=>{
    const ε = .0001 ** min(1, (20+u)/(20+100))
    // const ε = .0001 + .1 * (1-min(1, u/100))
    // const εU = [.005,.003,.001,.0005,.0003,.0002,.0001]
    // const ε = εU[min(floor(u/20),εU.length-1)]
    return cc > .5-ε && cc < .5+ε ? 0 : -inf
  })

}, {stats:'mks tks ess wsum t mar essu', plot:true, log:true, targets, max_time:5000, min_updates:200 })

```
```js:js_removed

const ts = Date.now()
const targets = transpose_objects(random_array(1000, () => {
  const a = random()
  const b = random_uniform(a, 1)
  const c = random_uniform(a, b)
  const cc = random_uniform(a, b)
  if (cc > .4999 && cc < .5001) return {a, b, c, cc}
}, defined))
print(`sampling approximate target on C'∈[.4999,.5001) took ${Date.now() - ts}ms`)

```
#_util