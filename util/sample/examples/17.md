#util/sample/examples/17
```js:js_input

const user = () => _state({
  t: now(),
  id: 'idle',
  hunger: 0,
  _events: [], // for counts
})
const events = {
  wake:   _if('asleep', daily(around(9,1)), 'idle'),
  sleep:  _if('idle',   daily(around(2,1)), 'asleep'),
  hunger: _at(randomly(1), inc('hunger', null/*hide*/)),
  snack:  _if(and(idle,x=>x.hunger>=3), randomly(2), x=>{ x.hunger-- }),
  meal:   _if(and(idle,x=>x.hunger>=5), randomly(1), x=>{ x.hunger=0 }),
}

```
---
```js:js_input

const x = simulate(user, now() + 1, events)
const h_next_meal = hour(find_event(x, events.meal)?.t)
// TODO: note confinement precision is limited by non-sample randomness in simulation
//       sample size (min_ess) can be traded off for increased precision
confine(h_next_meal, within(20,.5))
predict(count_event(x, events.meal),  'meals')
// predict(count_event(x, events.snack), 'snacks')

```
```js:js_removed

const idle = x => x.id == 'idle'
const count_event = (x,e) => sum(x._events, _e=>_e._source==e)
const find_event  = (x,e) => x._events.find(_e=>_e._source==e)
const hour = t => (t - ~~t) * 24

const _sample_options = {
  stats:'mks ess lwr r t',
  max_time:10000,
  // mks_tail:1,
  table:true,
  plot:true,
  hist:{ values:100 }, // allow more values to prevent truncation/sorting
  // size:1, // debug
  async:true,
  // workers:navigator.hardwareConcurrency,
}

// TODO: once you have a decent simulation, you attempt to predict _conditional_ probability of each event and highlight anomalies! you should be able to perform inference to condition on even rare events, as you do in earlier examples. remember you should be able to do something interesting even with very few logged events!

// TODO: design mechanism to expand both state and processes, e.g. calories, weight, etc
// TODO: allow both inexact (e.g. calories) and exact (e.g. weight) observations (logged events)
//       allow specifying sampling domains in logged events using special syntax? (e.g. ~``)
//       focus on daily aggregates (allowing for missing events) instead of precise event times?
//       allow significant differences day-to-day, e.g. using per-day unknowns?
//       run _daily_ simulations, w/ unknowns constrained by daily logs? (and prior knowledge)
//       later run weekly, annual, etc, simulations constrained by lower sims and prior knowledge?
//
// NOTE: trouble with above is that it is extremely difficult to truly "condition" on logged events, and it highlights the need for sequential weight relaxation instead of any sort of likelihood computation; that should allow extremely sophisticated inference, but requires (1) simulation w/ plausible domain, and (2) domain/weight relexation function
//
// NOTE: more accurate model of eating would require considering models of location & special states (e.g. driving, working, watching tv, etc), w/ certain special locations (e.g. home, hockey, work, etc) triggering special behavior
//
// TODO: instead of figuring out how to decompose, try implementing a monolithic model/simulation first, adding variables such as location, activity, last_ate, etc, and designing conditional mutation events ...

// states
// sleeping
// working
// driving
// biking
// toilet
// idle


```
#_util #_async