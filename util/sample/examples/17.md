#util/sample/examples/17
```js:js_input

const user = () => _state({
  t: now(),
  id: 'idle',
  hunger: 0,
  snacks: 0,
  meals: 0,
  _events: [],
})
const events = {
  wake:   _if('asleep', daily(around(9, 1)),    'idle'),
  sleep:  _if('idle',   daily(around(2, 1)),    'asleep'),
  // TODO: explore alternative implementation by conditioning on hunger
  //       first look at performance differences, then detailed logs
  eat:    _at(randomly(1), x=>{
    x.hunger++ // hidden if null returned below
    if (!idle(x)) return null // can't eat, hide event
    if (x.hunger >= 5) { x.hunger = 0; x.meals++; return {meal:true} }
    else if (x.hunger >= 3 && random_boolean(.5)) { x.hunger--; x.snacks++ }
    else return null // not eating, hide event
  }),
}

```
---
```js:js_input

const { meals } = simulate(user, now() + 3, events)
predict(meals)

```
```js:js_removed

const idle = x => x.id == 'idle'

const _sample_options = {
  stats:'mks ess lwr r t',
  max_time:15000,
  table:true,
  plot:true,
  // size:1, // debug
  async:true,
  hist:{ values:100 } // allow more values to prevent truncation/sorting
  // workers:navigator.hardwareConcurrency,
}

// TODO: once you have a decent simulation, you attempt to predict _conditional_ probability of each event and highlight anomalies! you should be able to perform inference to condition on even rare events, as you do in earlier examples. remember you should be able to do something interesting even with very few logged events!

// TODO: design mechanism to expand both state and processes, e.g. calories, weight, etc
// TODO: allow both inexact (e.g. calories) and exact (e.g. weight) observations (logged events)
//       allow specifying sampling domains in logged events using special syntax? (e.g. ~``)
//       focus on daily aggregates (allowing for missing events) instead of precise event times?
//       allow significant differences day-to-day, e.g. using per-day unknowns?
//       run _daily_ simulations, w/ unknowns constrained by daily logs? (and prior knowledge)
//       later run weekly, annual, etc, simulations constrained by lower sims and prior knowledge?
//
// NOTE: trouble with above is that it is extremely difficult to truly "condition" on logged events, and it highlights the need for sequential weight relaxation instead of any sort of likelihood computation; that should allow extremely sophisticated inference, but requires (1) simulation w/ plausible domain, and (2) domain/weight relexation function
//
// NOTE: more accurate model of eating would require considering models of location & special states (e.g. driving, working, watching tv, etc), w/ certain special locations (e.g. home, hockey, work, etc) triggering special behavior
//
// TODO: instead of figuring out how to decompose, try implementing a monolithic model/simulation first, adding variables such as location, activity, last_ate, etc, and designing conditional mutation events ...

// states
// sleeping
// working
// driving
// biking
// toilet
// idle


```
#_util #_async