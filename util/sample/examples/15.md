#util/sample/examples/15 Infer more complex [simulations](#util/sim), e.g. w/ state-dependent scheduling.
```js:js_input

const sim_days = round(30 * max(.25, context.r))
const [vars, params] = sleep_wake_state('olcan', { t: _6am - sim_days })
merge(params.olcan, { // sample & merge parameters to be inferred
  wake_hour:      { mean: sample(between(6,10)), stdev: sample(between(0,2)) },
  sleep_hour:     { mean: sample(between(0,3)),  stdev: sample(between(0,2)) },
  alt_wake_hour:  { mean: sample(between(6,10)), stdev: sample(between(0,2)) },
  alt_sleep_hour: { mean: sample(between(0,3)),  stdev: sample(between(0,2)) },
  p_alt: sample(between(0,1)),
})
// let alt = early (wake) to ensure alt params identifiable (i.e. non-swappable)
confine(2 * (params.olcan.wake_hour.mean - params.olcan.alt_wake_hour.mean),
  above(params.olcan.wake_hour.stdev + params.olcan.alt_wake_hour.stdev))
const x = state(vars, params, { events:true }) // enable x._events used below
const events = sleep_wake_events(x, 'olcan') // init events to mutate state
simulate(x, now(), events, { allow_next:true }) // simulate to next event >now
predict(last_event_name(x), 'next event') // predict next event via x._events
const sleep_lengths = hours_between_events(x, 'olcan.sleep', 'olcan.wake')
accumulate( // accumulate weights across runs, see notes below
  confine(event_hours(x, 'olcan.wake'), logged_wake_hours),
  confine(event_hours(x, 'olcan.sleep'), logged_sleep_hours),
  confine(sleep_lengths, logged_sleep_lengths)
)
predict(mean(sleep_lengths))
predict(stdev(sleep_lengths))

```
```js:js_removed

// note accumulation inhibits relative-tail mks convergence (even at 3+ mins)
// presumably causes a "slow drift" that adds up for relative tail
// fixed-tail is now default for accumulation & optimization
// identifiability (non-swappability) condition is important
// note "shortcutting" for condition has minimal benefit
// prior asymmetry is not important (empirically)

function sleep_wake_state(name, vars={}, params={}) {
  const p_alt = 0.5 // prob. alt schedule for first/next wake+sleep
  assign(vars[name] ??= {}, { alt: random_boolean(p_alt), awake: false })
  assign(params[name] ??= {}, {
    wake_hour: { mean: 8, stdev: 1 },
    sleep_hour: { mean: 0, stdev: 1 },
    alt_wake_hour: { mean: 7, stdev: 1 }, // < wake_hour for identifiability
    alt_sleep_hour: { mean: 0, stdev: 1 },
    p_alt,
  })
  return [vars, params]
}
function sleep_wake_events(x, name, events=[]) {
  x = x[name] // let x refer to nested object below
  const around_hour = h => around(h.mean, h.stdev)
  const wake_hour = around_hour(x.wake_hour)
  const sleep_hour = around_hour(x.sleep_hour)
  const alt_wake_hour = around_hour(x.alt_wake_hour)
  const alt_sleep_hour = around_hour(x.alt_sleep_hour)
  const wake_sched = daily(()=> x.alt ? alt_wake_hour : wake_hour)
  const sleep_sched = daily(()=> x.alt ? alt_sleep_hour : sleep_hour)
  events.push(...name_events({
    [name+'.wake']: _if(_=>!x.awake, wake_sched, _=>{ x.awake=true }),
    [name+'.sleep']: _if(_=>x.awake, sleep_sched, _=>{
      x.alt = random_boolean(x.p_alt) // alt schedule for next wake+sleep?
      x.awake = false
    }),
  }))
  return events
}

const last_event_name = x => last(x._events)._source._name
const event_hours = (x, name) => remove(x._events.map(e=>{
  if (e._source._name == name) return (e.t - ~~e.t) * 24
}))
const hours_between_events = (x, start, end) => remove(x._events.map((e,j,eJ)=>{
  if (j>0 && e._source._name == end && eJ[j-1]._source._name == start)
    return (e.t - eJ[j-1].t) * 24
}))

const context = () => ({
  logged_wake_hours: dist(event_log('wake','h')),
  logged_sleep_hours: dist(event_log('sleep','h')),
  logged_sleep_lengths: dist(event_log(undefined, (e,j,eJ) => {
    if (e.keyword == 'wake' && eJ[j+1]?.keyword == 'sleep')
      return (e.t - eJ[j+1].t) * 24
  }))
})

const _sample_options = {
  stats:'mks ess elw lwr r t',
  context, // as function defined above
  max_time:20000,
  // mks_tail:2,
  table:true,
  plot:true,
  // size:1, // debug
  async:true,
  workers:navigator.hardwareConcurrency, // ~optimal for time/sample (tpsa)
}

```
#_util #_logger #_async